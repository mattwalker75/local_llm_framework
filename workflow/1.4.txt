
1.4 Add Conversation Export with Multiple Formats
What it is: Add ability to export conversations in multiple formats: Markdown, JSON, PDF, and plain text, with configurable options (include timestamps, filter by date range, include system prompts). Detailed Explanation: Currently, conversations exist only in memory or as JSON files in the file system. Users cannot easily:
Share conversations with colleagues
Archive important discussions
Review conversations in readable format
Import conversations into other tools
This enhancement adds export functionality:
Multiple formats: Markdown (readable), JSON (programmatic), PDF (print), TXT (simple)
Configuration options: Include/exclude timestamps, system prompts, metadata
Date range filtering: Export specific time periods
CLI: llf chat export --format markdown --output chat.md
GUI: Export button with format selector
Benefits:
Data Portability: Can move conversations between tools
Archival: Keep important discussions for reference
Sharing: Send formatted conversations to colleagues
Analysis: Import JSON into analysis tools
Compliance: Meet data retention requirements
Files to Update:
llf/cli.py - Add export command (around line 600, in interactive loop)
llf/gui.py - Add export button and handler (around line 450)
llf/memory_manager.py - Add export_conversation method
llf/prompt_config.py - Add method to extract conversation without system prompts
New file: llf/exporters.py - Conversation export formatters
Implementation Guide:

# Create new file: llf/exporters.py

"""
Conversation Export Utilities

Formats conversation history for export in various formats.
"""

from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime
import json


class ConversationExporter:
    """Export conversations in multiple formats."""
    
    @staticmethod
    def to_markdown(
        conversation: List[Dict[str, str]],
        include_timestamps: bool = True,
        include_system: bool = False,
        title: str = "Conversation Export"
    ) -> str:
        """
        Export conversation to Markdown format.
        
        Args:
            conversation: List of message dicts with 'role' and 'content'
            include_timestamps: Include timestamp for each message
            include_system: Include system prompts
            title: Document title
        
        Returns:
            Markdown formatted string
        """
        md = f"# {title}\n\n"
        md += f"*Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n"
        md += "---\n\n"
        
        for idx, msg in enumerate(conversation, 1):
            role = msg.get('role', 'unknown')
            content = msg.get('content', '')
            timestamp = msg.get('timestamp', '')
            
            # Skip system messages if not included
            if role == 'system' and not include_system:
                continue
            
            # Format role
            if role == 'user':
                role_display = "ðŸ‘¤ **User**"
            elif role == 'assistant':
                role_display = "ðŸ¤– **Assistant**"
            elif role == 'system':
                role_display = "âš™ï¸ **System**"
            else:
                role_display = f"**{role.capitalize()}**"
            
            md += f"## Message {idx}: {role_display}\n\n"
            
            if include_timestamps and timestamp:
                md += f"*{timestamp}*\n\n"
            
            md += f"{content}\n\n"
            md += "---\n\n"
        
        return md
    
    @staticmethod
    def to_json(
        conversation: List[Dict[str, str]],
        pretty: bool = True,
        include_metadata: bool = True
    ) -> str:
        """
        Export conversation to JSON format.
        
        Args:
            conversation: List of message dicts
            pretty: Pretty-print JSON
            include_metadata: Include export metadata
        
        Returns:
            JSON formatted string
        """
        export_data = {
            "conversation": conversation
        }
        
        if include_metadata:
            export_data["metadata"] = {
                "exported_at": datetime.now().isoformat(),
                "message_count": len(conversation),
                "format_version": "1.0"
            }
        
        if pretty:
            return json.dumps(export_data, indent=2)
        else:
            return json.dumps(export_data)
    
    @staticmethod
    def to_text(
        conversation: List[Dict[str, str]],
        include_timestamps: bool = True,
        separator: str = "\n" + "="*80 + "\n"
    ) -> str:
        """
        Export conversation to plain text format.
        
        Args:
            conversation: List of message dicts
            include_timestamps: Include timestamp for each message
            separator: Message separator
        
        Returns:
            Plain text formatted string
        """
        text = f"Conversation Export - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        text += "="*80 + "\n\n"
        
        for msg in conversation:
            role = msg.get('role', 'unknown').upper()
            content = msg.get('content', '')
            timestamp = msg.get('timestamp', '')
            
            text += f"[{role}]"
            if include_timestamps and timestamp:
                text += f" ({timestamp})"
            text += "\n"
            text += content + "\n"
            text += separator
        
        return text
    
    @staticmethod
    def to_pdf(
        conversation: List[Dict[str, str]],
        output_path: Path,
        title: str = "Conversation Export"
    ) -> bool:
        """
        Export conversation to PDF format.
        
        Requires: pip install reportlab
        
        Args:
            conversation: List of message dicts
            output_path: Path to save PDF
            title: Document title
        
        Returns:
            True if successful
        """
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
            from reportlab.lib.enums import TA_LEFT
        except ImportError:
            raise ImportError("PDF export requires reportlab: pip install reportlab")
        
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=letter,
            topMargin=0.5*inch,
            bottomMargin=0.5*inch
        )
        
        styles = getSampleStyleSheet()
        story = []
        
        # Title
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            spaceAfter=12
        )
        story.append(Paragraph(title, title_style))
        story.append(Spacer(1, 0.2*inch))
        
        # Metadata
        meta_text = f"Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        story.append(Paragraph(meta_text, styles['Normal']))
        story.append(Spacer(1, 0.3*inch))
        
        # Messages
        for msg in conversation:
            role = msg.get('role', 'unknown')
            content = msg.get('content', '')
            
            # Role header
            role_style = ParagraphStyle(
                'Role',
                parent=styles['Heading2'],
                fontSize=14,
                textColor='blue' if role == 'user' else 'green'
            )
            story.append(Paragraph(f"{role.upper()}", role_style))
            story.append(Spacer(1, 0.1*inch))
            
            # Content
            content_style = ParagraphStyle(
                'Content',
                parent=styles['Normal'],
                alignment=TA_LEFT,
                spaceAfter=12
            )
            story.append(Paragraph(content, content_style))
            story.append(Spacer(1, 0.2*inch))
        
        doc.build(story)
        return True

# In llf/cli.py, add export command to interactive loop (around line 600)

# In the interactive loop, add new command handling
elif user_input.lower().startswith('/export'):
    # Parse export command
    parts = user_input.split()
    
    if len(parts) < 2:
        console.print("[yellow]Usage: /export <format> [filename][/yellow]")
        console.print("Formats: markdown, json, text, pdf")
        console.print("Example: /export markdown my_chat.md")
        continue
    
    export_format = parts[1].lower()
    filename = parts[2] if len(parts) > 2 else f"conversation_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    # Add extension if not provided
    if '.' not in filename:
        ext_map = {
            'markdown': '.md',
            'json': '.json',
            'text': '.txt',
            'pdf': '.pdf'
        }
        filename += ext_map.get(export_format, '.txt')
    
    # Export conversation
    try:
        from .exporters import ConversationExporter
        exporter = ConversationExporter()
        
        if export_format == 'markdown':
            content = exporter.to_markdown(conversation_history)
            Path(filename).write_text(content)
        elif export_format == 'json':
            content = exporter.to_json(conversation_history)
            Path(filename).write_text(content)
        elif export_format == 'text':
            content = exporter.to_text(conversation_history)
            Path(filename).write_text(content)
        elif export_format == 'pdf':
            exporter.to_pdf(conversation_history, Path(filename))
        else:
            console.print(f"[red]Unknown format: {export_format}[/red]")
            continue
        
        console.print(f"[green]âœ“[/green] Conversation exported to: {filename}")
    
    except Exception as e:
        console.print(f"[red]Export failed: {e}[/red]")
    
    continue

# Also add /export to help text
console.print("  /export <format> [file] - Export conversation (formats: markdown, json, text, pdf)")

